name: Run on host

on:
    workflow_call:
        inputs:
            idf_version:
                required: true
                type: string
            app_name:
                type: string
                required: true
            app_path:
                type: string
                required: true
            component_path:
                type: string
                required: true
            upload_artifacts:
                type: boolean
                required: true
            run_executable:
                type: boolean
                required: true
            run_coverage:
                type: boolean
                required: true
            pre_run_script:
                type: string
                required: false
            publish_unit_test_result:
                type: boolean
                required: false

jobs:
  build:
      name: Build App
      runs-on: ubuntu-22.04
      permissions:
        checks: write
        contents: write
      container: espressif/idf:${{inputs.idf_version}}
      steps:
        - name: Checkout esp-protocols
          uses: actions/checkout@v4
          with:
            path: esp-protocols
        - name: Build ${{ inputs.app_name }} with IDF-${{ inputs.idf_version }}
          shell: bash
          run: |
            set -euo pipefail
            component=$(basename ${{ inputs.component_path }})
            if [ -f "${{ inputs.pre_run_script }}" ]; then
              source ${{ inputs.pre_run_script }} ${{ inputs.idf_version }} $component
            fi
            . ${IDF_PATH}/export.sh
            cd ${{inputs.app_path}}
            rm -rf sdkconfig sdkconfig.defaults build
            # The sdkconfig.ci.linux specifies Linux as the build target with apropriate settings.
            cp sdkconfig.ci.linux sdkconfig.defaults
            idf.py -D CMAKE_BUILD_TYPE=RelWithDebInfo build
            if [ "${{ inputs.run_executable}}" == "false" ]; then
                echo "Executeable wasn't run"
                exit 0
            fi
            # Best-effort: enable core dumps so we can generate gdb backtraces on crashes.
            ulimit -c unlimited || true

            # Ensure gdb exists (container image may not ship it).
            if ! command -v gdb >/dev/null 2>&1; then
              apt-get update
              apt-get install -y gdb
            fi

            set +e
            ./build/${{inputs.app_name}}.elf
            rc=$?
            set -e

            if [ $rc -ne 0 ]; then
              echo "::group::Core dump files (if any)"
              ls -la core* 2>/dev/null || true
              echo "::endgroup::"

              corefile="$(ls -1t core* 2>/dev/null | head -n 1 || true)"
              if [ -n "$corefile" ]; then
                echo "::group::gdb backtrace from core ($corefile)"
                gdb -q -batch \
                  -ex "set pagination off" \
                  -ex "bt full" \
                  -ex "thread apply all bt full" \
                  ./build/${{inputs.app_name}}.elf "$corefile" || true
                echo "::endgroup::"
              else
                echo "::group::gdb backtrace (re-run under gdb; may not reproduce)"
                timeout 60s gdb -q -batch \
                  -ex "set pagination off" \
                  -ex run \
                  -ex "bt full" \
                  -ex "thread apply all bt full" \
                  --args ./build/${{inputs.app_name}}.elf || true
                echo "::endgroup::"
              fi
            fi

            exit $rc
        - name: Publish Unit Test Result
          uses: EnricoMi/publish-unit-test-result-action@v2
          if: ${{ inputs.publish_unit_test_result }}
          with:
            files: ${{inputs.component_path}}/**/*junit.xml
        - name: Build with Coverage Enabled
          shell: bash
          if: ${{ inputs.run_coverage }}
          run: |
            set -euo pipefail
            component=$(basename ${{ inputs.component_path }})
            if [ -f "${{ inputs.pre_run_script }}" ]; then
              source ${{ inputs.pre_run_script }} ${{ inputs.idf_version }} $component
            fi
            . ${IDF_PATH}/export.sh
            cd $GITHUB_WORKSPACE/${{inputs.app_path}}
            rm -rf build sdkconfig sdkconfig.defaults
            idf.py fullclean
             # The sdkconfig.ci.coverage specifies Linux as the build target with apropriate settings (CONFIG_GCOV_ENABLED=y).
            cp sdkconfig.ci.coverage sdkconfig.defaults
            idf.py -D CMAKE_BUILD_TYPE=RelWithDebInfo build

            # Best-effort: enable core dumps so we can generate gdb backtraces on crashes.
            ulimit -c unlimited || true

            # Ensure gdb exists (container image may not ship it).
            if ! command -v gdb >/dev/null 2>&1; then
              apt-get update
              apt-get install -y gdb
            fi

            set +e
            ./build/${{inputs.app_name}}.elf
            rc=$?
            set -e

            if [ $rc -ne 0 ]; then
              echo "::group::Core dump files (if any)"
              ls -la core* 2>/dev/null || true
              echo "::endgroup::"

              corefile="$(ls -1t core* 2>/dev/null | head -n 1 || true)"
              if [ -n "$corefile" ]; then
                echo "::group::gdb backtrace from core ($corefile)"
                gdb -q -batch \
                  -ex "set pagination off" \
                  -ex "bt full" \
                  -ex "thread apply all bt full" \
                  ./build/${{inputs.app_name}}.elf "$corefile" || true
                echo "::endgroup::"
              else
                echo "::group::gdb backtrace (re-run under gdb; may not reproduce)"
                timeout 60s gdb -q -batch \
                  -ex "set pagination off" \
                  -ex run \
                  -ex "bt full" \
                  -ex "thread apply all bt full" \
                  --args ./build/${{inputs.app_name}}.elf || true
                echo "::endgroup::"
              fi
            fi

            exit $rc
        - name: Run Coverage
          shell: bash
          if: ${{ inputs.run_coverage }}
          run: |
            apt-get update && apt-get install -y rsync
            python3 -m venv .venv
            source .venv/bin/activate
            python3 -m pip install gcovr
            cd $GITHUB_WORKSPACE/${{inputs.component_path}}
            component=$(basename ${{ inputs.component_path }})
            gcov `find . -name "$component*gcda"`
            gcovr --gcov-ignore-parse-errors -g -k -r . --html index.html -x ${{inputs.app_name}}_coverage.xml
            mkdir ${{inputs.app_name}}_coverage_report
            touch ${{inputs.app_name}}_coverage_report/.nojekyll
            cp index.html ${{inputs.app_name}}_coverage_report
            cp -rf ${{inputs.app_name}}_coverage_report ${{inputs.app_name}}_coverage.xml $GITHUB_WORKSPACE
        - name: Code Coverage Summary Report
          if: ${{ inputs.run_coverage }}
          uses: irongut/CodeCoverageSummary@v1.3.0
          with:
            filename: esp-protocols/**/${{inputs.app_name}}_coverage.xml
            badge: true
            fail_below_min: false
            format: markdown
            hide_branch_rate: false
            hide_complexity: false
            indicators: true
            output: both
            thresholds: '60 80'
        - name: Write to Job Summary
          run: cat code-coverage-results.md >> $GITHUB_STEP_SUMMARY
          if: ${{ inputs.run_coverage }}
        - name: Upload files to artifacts for run-target job
          uses: actions/upload-artifact@v4
          if: ${{ inputs.run_coverage }}
          with:
            name: ${{inputs.app_name}}_coverage_report
            path: |
              ${{inputs.component_path}}/${{inputs.app_name}}_coverage_report
            if-no-files-found: error
